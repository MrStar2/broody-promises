var utils = require("./utils"),    macrotask = require("./macrotask"),    Promise, Subscriber;function curryResolve(promise) {    return function(value) {        resolve(promise, value);    }}function curryReject(promise) {    return function(error) {        reject(promise, error);    }}function Race() {    this.counter = 0;    this.closed = false;}Race.prototype.add = function(fn) {    var self = this,        target;    target = function() {        if (self.counter == 0 && !self.closed) {            self.counter++;            target.callCount++;            fn.apply(context, arguments);        }    };    target.callCount = 0;    return target;};Race.prototype.close = function() {    this.closed = true;}function call(fn) {    return fn.apply(void 0, arguments);}function onceOf() {    var args, counter;    counter = 0;    args = Array.prototype.slice.call(arguments, 1);}function resolve(promise, value) {    var doResolve, doReject,        race, resolvePromise, rejectPromise,        then;    if (!utils.isNull(promise._state)) {        throw new Error("Can not resolve fulfilled promise");    }    if (value === promise) {        return reject(promise, new TypeError("Could not resolve promise with itself"));    }    doResolve = curryResolve(promise);    doReject = curryReject(promise);    if (value instanceof Promise) {        if ( utils.isNull(value._state) ) {            value.then(doResolve, doReject);            return;        }        value._state ? doResolve(value._value) : doReject(value._error);        return;    }    // spec 2.3.3    if (utils.isObject(value) || utils.isFunction(value)) {        try {            then = value.then;        } catch (err) {            reject(promise, err);            return;        }        if (utils.isFunction(then)) {            race = new Race();            resolvePromise = race.add(doResolve);            rejectPromise = race.add(doReject);            try {                then.call(value, resolvePromise, rejectPromise);            } catch (err) {                if (resolvePromise.callCount == 0 && rejectPromise.callCount == 0) {                    reject(promise, err);                    race.close();                }            }            return;        }    }    promise._state = true;    promise._value = value;    utils.forEach(promise._subscribers, function(subscriber) {        subscriber.resolve(value);    });}function reject(promise, error) {    if ( !utils.isNull(promise._state) ) {        throw new Error("Can not reject fulfilled/rejected promise");    }    promise._state = false;    promise._error = error;    utils.forEach(promise._subscribers, function(subscriber) {        subscriber.reject(error);    });}Subscriber = function(onFulfilled, onRejected, options) {    this.promise = new Promise(utils.noop, options);    this.onFulfilled = onFulfilled;    this.onRejected  = onRejected;    this.options = options;};Subscriber.prototype = {    constructor: Subscriber,    resolve: function(value) {        var self = this;        if ( !utils.isFunction(self.onFulfilled) ) {            resolve(self.promise, value);            return;        }        (this.options.sync ? call : macrotask)(function() {            var response;            try {                response = self.onFulfilled.call(void 0, value);            } catch (err) {                reject(self.promise, err);                return;            }            resolve(self.promise, response);        });    },    reject: function(error) {        var self = this;        if ( !utils.isFunction(self.onRejected) ) {            reject(self.promise, error);            return;        }        (this.options.sync ? call : macrotask)(function() {            var response;            try {                response = self.onRejected.call(void 0, error);            } catch (err) {                reject(self.promise, err);                return;            }            resolve(self.promise, response);        });    }};Promise = function(resolver, options) {    var self = this,        doResolve, doReject;    if (!(this instanceof Promise)) {        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");    }    if (!utils.isFunction(resolver)) {        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');    }    this.options = utils.extend({}, this.constructor.DEFAULTS, options);    this._subscribers = [];    this._state = null;    this._value = null;    this._error = null;    doResolve = curryResolve(self);    doReject = curryReject(self);    try {        resolver(doResolve, doReject);    } catch (err) {         doReject(err);    }};Promise.DEFAULTS = {    sync: true};Promise.prototype = {    constructor: Promise,    "then": function(onFulfilled, onRejected) {        var subscriber;        this._subscribers.push((subscriber = new Subscriber(onFulfilled, onRejected, this.options)));        // if promise is fulfilled/rejected already        if ( !utils.isNull(this._state) ) {            this._state ? subscriber.resolve(this._value) : subscriber.reject(this._error);        }        return subscriber.promise;    },    "finally": function(onAnyWay) {        return this.then(function(value) {            onAnyWay(null, value);        }, function(err) {            onAnyWay(err);        });    },    "catch": function(onReject) {        return this.then(null, onReject);    },    "value": function() {        if (utils.isNull(this._state)) {            throw new Error("Can not retrieve value from not fulfilled promise");        }        if (this._state) {            return this._value;        }        throw this._error;    }};Promise.all = function(promises, options) {    return new Promise(function(resolve, reject) {        var i, len, results, remaining, rejected,            target, getComplete, complete, next;        len       = promises.length;        remaining = len;        rejected  = false;        options = utils.extend({ strict: true }, this.constructor.DEFAULTS, options || {});        if (!utils.isArray(promises)) {            throw new TypeError("Array is expected");        }        results = new Array(len);        if (!remaining) {            resolve(results);            return;        }        getComplete = function(i) {            return function(value) {                results[i] = value;            }        };        next = function() {            remaining--;            if (remaining === 0 && !rejected) {                resolve(results);            }        };        for (i = 0; i < len; i++) {            target = promises[i];            complete = getComplete(i);            if (target instanceof Promise) {                target                    .then(complete)                    .catch(function(error) {                        if (options.strict && !rejected) {                            reject(error);                            rejected = true;                        }                    })                    .finally(next);            } else {                complete(target);                next();            }        }    }, options);};Promise.resolve = function(value, options) {    return new Promise(function(resolve) {        resolve(value);    }, options);};Promise.reject = function(err, options) {    return new Promise(function(resolve, reject) {        reject(err);    }, options);};module.exports = Promise;