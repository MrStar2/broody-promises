var utils = require("./utils"),    Promise, Subscriber;function curryResolve(promise) {    return function(value) {        resolve(promise, value);    }}function curryReject(promise) {    return function(error) {        reject(promise, error);    }}function counter(fn, context) {    var target;    target = function() {        target.callCount++;        fn.apply(context, arguments);    };    target.callCount = 0;    return target;}function resolve(promise, value) {    var doResolve, doReject, then;    if (!utils.isNull(promise._state)) {        throw new Error("Can not resolve fulfilled promise");    }    if (value === promise) {        return utils.reject(promise)(new TypeError("Could not resolve promise with itself"));    }    doResolve = counter(curryResolve(promise));    doReject = counter(curryReject(promise));    if (value instanceof Promise) {        value.then(doResolve, doReject);        return;    }    if (utils.isObject(value) || utils.isFunction(value)) {        try {            then = value.then;        } catch (err) {            reject(promise, err);            return;        }        if (utils.isFunction(then)) {            try {                then.call(value, doResolve, doReject);            } catch (err) {                if (doResolve.callCount == 0 && doReject.callCount == 0) {                    reject(promise, err);                }            }            return;        }    }    promise._state = true;    promise._value = value;    utils.forEach(promise._subscribers, function(subscriber) {        subscriber.resolve(value);    });}function reject(promise, error) {    if (!utils.isNull(promise._state)) {        throw new Error("Can not reject fulfilled promise");    }    promise._state = false;    promise._error = error;    utils.forEach(promise._subscribers, function(subscriber) {        subscriber.reject(error);    });}Subscriber = function(resolve, reject, promise) {    this._resolve = resolve;    this._reject  = reject;    this.promise = promise;};Subscriber.prototype = {    constructor: Subscriber,    _notify: function(action, error, val) {        var self = this,            response, strategy, value;        strategy = error ? reject : resolve;        value    = error ? error  : val;        if (!utils.isFunction(action)) {            strategy(this.promise, value);            return;        }        try {            response = action.call(null, value);        } catch(_err) {            reject(this.promise, _err);            return;        }        resolve(this.promise, response);    },    resolve: function(value) {        this._notify(this._resolve, null, value);    },    reject: function(error) {        this._notify(this._reject, error);    }};Promise = function(resolver) {    var self = this,        doResolve, doReject;    if (!(this instanceof Promise)) {        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");    }    if (!utils.isFunction(resolver)) {        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');    }    this._subscribers = [];    this._state = null;    this._value = null;    this._error = null;    doResolve = curryResolve(self);    doReject = curryReject(self);    try {        resolver(doResolve, doReject);    } catch (err) {        doReject(err);    }};Promise.DEFAULTS = {};Promise.prototype = {    constructor: Promise,    "then": function(onResolve, onReject) {        var subscriber;        this._subscribers.push((subscriber = new Subscriber(onResolve, onReject, new Promise(utils.noop))));        // if promise is fullfilled already        if (!utils.isNull(this._state)) {            this._state ? subscriber.resolve(this._value) : subscriber.reject(this._error);        }        return subscriber.promise;    },    "finally": function(onAnyWay) {        return this.then(function(value) {            onAnyWay(null, value);        }, function(err) {            onAnyWay(err);        });    },    "catch": function(onReject) {        return this.then(null, onReject);    },    "value": function() {        if (!this._state) {            if (this._error) {                throw this._error;            }            throw new Error("Can not retrieve value from not fullfilled promise");        }        return this._value;    }};Promise.all = function(promises, strict) {    return new Promise(function(resolve, reject) {        var i, len, results, remaining, rejected,            target, getComplete, complete, next;        len       = promises.length;        remaining = len;        rejected  = false;        strict    = utils.isBoolean(strict) ? strict : true;        if (!utils.isArray(promises)) {            throw new TypeError("Array is expected");        }        results = new Array(len);        if (!remaining) {            resolve(results);            return;        }        getComplete = function(i) {            return function(value) {                results[i] = value;            }        };        next = function() {            remaining--;            if (remaining === 0 && !rejected) {                resolve(results);            }        };        for (i = 0; i < len; i++) {            target = promises[i];            complete = getComplete(i);            if (target instanceof Promise) {                target                    .then(complete)                    .catch(function(error) {                        if (strict && !rejected) {                            reject(error);                            rejected = true;                        }                    })                    .finally(next);            } else {                complete(target);                next();            }        }    });};Promise.resolve = function(value) {    if (value instanceof Promise) {        return value;    }    return new Promise(function(resolve) {        resolve(value);    });};Promise.reject = function(err) {    return new Promise(function(resolve, reject) {        reject(err);    });};module.exports = Promise;